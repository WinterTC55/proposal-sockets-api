<pre class='metadata'>
Title: Sockets API
Shortname: common-web-platform-api
Group: wintercg
Status: w3c/CG-DRAFT
Level: none
URL: https://sockets-api.proposal.wintercg.org/
Repository: https://github.com/wintercg/proposal-sockets-api
Editor: Dominik Picheta, Cloudflare https://cloudflare.com/, dominik@cloudflare.com
Abstract: Sockets API for Non-Browser EcmaScript-based runtimes.
Markup Shorthands: markdown yes
</pre>
<pre class=link-defaults>
spec:url; type:interface; text:URL
spec:html; type:attribute; for:Window; text:navigator
spec:html; type:method; for:Connect; text:connect
</pre>

Introduction {#intro}
=====================

*This section is non-normative.*

This document defines an API for establishing TCP connections in Non-Browser JavaScript runtime
environments. Existing standard APIs are reused as much as possible, for example ReadableStream
and WritableStream are used for reading and writing from a socket. Some options are inspired
by the existing Node.js `net.Socket` API. 


`Socket` interface {#socket-interface}
======================================

A `Socket` can be constructed using the global {{connect}} method, or a `connect` method
defined on a <a>binding object</a>.

<pre class="idl">
[Exposed=*]
interface Socket {
  readonly attribute ReadableStream readable;
  readonly attribute WritableStream writable;

  readonly attribute Promise&lt;undefined> closed;
  Promise&lt;undefined> close();

  Socket startTls();
};
</pre>

The terms {{ReadableStream}} and {{WritableStream}} are defined in [[!WHATWG-STREAMS]].

Instances of {{Socket}} are created with fields described in the following table:

<pre class="simpledef">
{{readable}}: a {{ReadableStream}} which receives data from the server the socket is connected to
{{writable}}: a {{WritableStream}} which sends data to the server the socket is connected to
{{closed}}: a promise that will be rejected (if Socket connection fails or there is another error) or resolved (if the connection is gracefully closed)
</pre>

Methods available on a {{Socket}} instance are described by the following table:

<pre class="simpledef">
{{close()}}: closes the socket and its underlying connection
{{startTls()}}: begins TLS session on the socket connection, see <a>`startTls` method</a>
</pre>

`connect` method {#connect}
===========================

<pre class="idl">
[Exposed=*]
dictionary SocketAddress {
  DOMString hostname;
  unsigned short port;
};

typedef (DOMString or SocketAddress) AnySocketAddress;

enum SecureTransportKind { "off", "on", "starttls" };

[Exposed=*]
dictionary SocketOptions {
  SecureTransportKind secureTransport;
};

[Exposed=*]
interface Connect {
  Socket connect(AnySocketAddress address, optional SocketOptions opts);
};
</pre>

`SocketOptions` dictionary
---------------------------



`startTls` method {#starttls-method}
=============================

The <dfn>`startTls` method</dfn> enables opportunistic TLS which is a requirement for some protocols
(primarily postgres/mysql and other DB protocols).

The `startTls` method must fail with an exception if the `secureTransport` option set on
Socket instance it was called on is not equal to "starttls".

In this `secureTransport` mode of operation the Socket begins the
connection in plain-text, with messages read and written without any encryption. Then once the
`startTls` method is called on the Socket, the following shall take place:

* the original Socket is closed, though the original connection is kept alive
* a secure TLS connection is established over that connection
* a new Socket is created and returned from the `startTls` call

Here is a simple code example showing usage:

```js
let sock = connect("google.com:443", { secureTransport: "starttls" });
// ... some code here ...
// We want to StartTLS at this point.
let tlsSock = sock.startTls();
```

Binding object {#binding-object}
================================

The <dfn>binding object</dfn> defines Socket `connect` options. The options it contains can modify the
behaviour of the `connect` invoked on it. Some of the options it can define:

* TLS settings
* The HTTP proxy to use for the socket connection